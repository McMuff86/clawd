# 2025-02-05 - Daily Log

## RhinoAssemblyOutliner Plugin - Grosse Session

Heute massive Fortschritte beim neuen Rhino 8 Plugin Projekt.

### Was gebaut wurde
- **Repo:** github.com/McMuff86/RhinoAssemblyOutliner
- **Ziel:** SolidWorks FeatureManager-Style hierarchischer Block Outliner f√ºr Rhino 8
- **Distribution:** Yak Package Manager

### Architektur
- **Model Layer:** AssemblyNode, BlockInstanceNode, DocumentNode, AssemblyTreeBuilder
- **UI Layer:** AssemblyOutlinerPanel (IPanel), AssemblyTreeView (TreeGridView), DetailPanel
- **Services:** VisibilityService (Show/Hide/Isolate), SelectionSyncService
- **Features:** Bidirektionale Selektion, Visibility Toggle (üëÅ), Context Menu, Block Type Icons (üì¶üîóüìé), User Attributes, Search/Filter

### Multi-Agent Approach
Spawned 4 Sub-Agents:
1. **Researcher** - Rhino 8 API, Eto.Forms, Yak Packaging recherchiert
2. **Coder** - Model + UI + Services implementiert
3. **Tester** - Testing-Strategie & Error Handling
4. **Docs** - README, ARCHITECTURE.md, PACKAGING.md

### Build Issues (gel√∂st)
- Timer Ambiguit√§t (System.Threading vs Eto)
- System.Drawing.Common Referenz
- `IsLinkedDefinition` gibt's nicht ‚Üí `UpdateType == Linked` Pattern
- .rhp Output Extension
- Plugin GUID in AssemblyInfo

### Aktueller Blocker
**Panel Registration Error:** "plugInId Can't be Guid.Empty"
- Problem: `Panels.RegisterPanel()` bekommt GUID nicht korrekt
- Location: Line 36 in RhinoAssemblyOutlinerPlugin.cs
- N√§chster Schritt: SampleCsEto von mcneel/rhino-developer-samples (branch "8") studieren

### Technische Details
- **Plugin GUID:** 68EE26AC-D516-4F50-9DE2-46D105702323
- **Target:** net7.0-windows
- **Packages:** RhinoCommon 8.0.23304.9001, Eto.Forms 2.8.0
- **Command:** `_AssemblyOutliner`
- **Company:** Muff Software, Author: Adrian Muff

### Key Learnings
- Panel Registration muss im **Command Constructor** passieren, NICHT in Plugin.OnLoad()
- Rhino 8 braucht net7.0-windows mit NU1701 Warning suppressed
- `<TargetExt>.rhp</TargetExt>` f√ºr korrekten Output

---

## Per-Instance Component Visibility - PoC abgeschlossen

### Das Ziel
Komponenten INNERHALB einer Block-Instanz ausblenden - etwas das Rhino nativ nicht kann.

### C# DisplayConduit Ansatz getestet

**v1 (gescheitert):** `Objects.Hide()` ‚Üí Objekt nicht mehr selektierbar
**v2 (teilweise):** `PreDrawObject` + `e.DrawObject=false` ‚Üí Selection funktioniert!

### Ergebnisse
- ‚úÖ Konzept funktioniert grunds√§tzlich
- ‚úÖ Selection bleibt erhalten (v2)
- ‚ùå Ghost Artifacts beim Verschieben
- ‚ùå Keine Selection Highlight
- ‚ùå Ctrl+Shift+V hilft nicht

### Fazit
**C# DisplayConduit = PoC only, nicht production-ready.**
C++ SDK n√∂tig f√ºr saubere Display Pipeline Integration.

### Dokumentation erstellt
- `docs/PER_INSTANCE_VISIBILITY.md` - Alle Learnings
- `docs/CPP_ROADMAP.md` - Plan f√ºr C++ Implementation

### Key Learning
DisplayConduit zeichnet "ausserhalb" von Rhino's Pipeline ‚Üí Rhino weiss nicht welche Screen-Regionen invalidiert werden m√ºssen ‚Üí Ghost Artifacts.

---

## C++ SDK Research & Setup (Nachmittag)

### SDK Research abgeschlossen
Neues Dokument: `docs/CPP_SDK_RESEARCH.md`

**Key Findings:**
- `CRhinoDisplayConduit::ExecConduit()` mit `SC_DRAWOBJECT` Channel
- **`return false`** √ºberspringt Default Draw ‚Üí echte Pipeline-Integration!
- `CRhinoInstanceDefinition::Object(i)` zum Iterieren von Komponenten
- `CRhinoDisplayPipeline::DrawObject/DrawBrep/DrawMesh` f√ºr Custom Draw
- `ON_UserData` f√ºr per-Instance Visibility State

Das sollte das Ghost-Problem l√∂sen!

### Visual Studio Setup
- VS 2022 Update l√§uft
- **v142 Toolset** wird ben√∂tigt (Rhino 8 SDK Requirement)
- Rhino 8 C++ SDK installiert ‚úÖ
- Rhino VS Extension installiert ‚úÖ

### C++ Projekt erstellt
- **Projekt:** `RhinoAssemblyOutliner.Native`
- **Location:** `src/RhinoAssemblyOutliner.Native/`
- **Command:** `NativeTest`
- **Plugin type:** General Utility
- **Target:** Rhino 8

### N√§chste Schritte
1. v142 MSVC Build Tools installieren (l√§uft gerade)
2. Hello World Plugin builden & testen
3. DisplayConduit mit `SC_DRAWOBJECT` + `return false` testen
4. Per-Instance Visibility in C++ implementieren

### Monorepo-Struktur
```
RhinoAssemblyOutliner/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ RhinoAssemblyOutliner/         # C# Plugin (UI)
‚îÇ   ‚îî‚îÄ‚îÄ RhinoAssemblyOutliner.Native/  # C++ Plugin (Display) ‚Üê NEU
‚îî‚îÄ‚îÄ RhinoAssemblyOutliner.sln
```
